/* Lamport mutual exclusion Meld version */

type route edge(node, node).
type linear update-time(node, int, int).
type linear my-time(node, int).
type linear add-request(node, int).
type linear add-queue(node, queue, tuple).
type linear ack(node, node, int).
type linear remove-request(node, int).
type linear remove-queue(node, queue, tuple).
type linear request-ressource(node).
type linear ressource-requested(node).
type linear select-min-ack(node).
type linear min-ack(node,int).
type linear CS(node).
type linear CS_instructions(node).
type linear countdown(node, int).
type counter(node, int).
type queue(node, list node, list int).

/* We use a fully connected graph of processes */
!edge(@1, @2). !edge(@1, @3). !edge(@1, @4).
!edge(@2, @1). !edge(@2, @3). !edge(@2, @4).
!edge(@3, @2). !edge(@3, @1). !edge(@3, @4).
!edge(@4, @2). !edge(@4, @3). !edge(@4, @1).

request-ressource(A).
my-time(A, 0).
start(A).
!counter(A, 3).
queue(A, [], []).

start(A), !counter(A, Total) -o countdown(A, Total).

/* Updates the Lamport clock */
update-time(A, TLocal, TRemote),
TLocal < TRemote
	-o my-time(A, TRemote+1).

update-time(A, TLocal, TRemote),
TLocal >= TRemote
	-o my-time(A, TLocal+1).
/* Would it be possible to express this in a nicer way (only one rule)? */
/* Will the others my-time(A, _) be removed? */

/* Receive a request ressource from B */
/* 1) Add it to the queue */
/* 2) Send back a Ack */
!edge(A, B),
add-request(A, B, Tx),
queue(A, Nodes, Times),
my-time(A, Tm)
	-o queue(A, addnodetoqueues(Nodes, Times, B, Tx), addnodetoqueuestime(Nodes, Times, B, Tx)),
	   receive-ack(B, A, Tm)
	   update-time(A, Tm, Tx).

/* Receives a remove-request */
/* Remove the B, Tx from the queue */
!edge(A, B),
remove-request(A, B, Tx),
queue(A, Nodes, Times),
my-time(A, Tm)
	-o queue(A, removenodefromqueues(Nodes, Times, B, Tx), removenodefromqueuestimes(Nodes, Times, B, Tx)),
	   update-time(A, Tm, Tx).

/* 1) Add the request to its own queue */
/* 2) Send to everybody, Pi request ressource at Tm */
request-ressource(A)
my-time(A, Tm)
	-o add-request(A, A, Tm),
           {B | !edge(A,B) | add-request(B, A, Tm), ressource-requested(A)}.


/* Doesn't work as we have to dequeue a request -> must be a list */
/* select-min-request(A)*/
/*	-o [min => Tx | B | !edge(A,B), request(B, Tx), min-request(A,Tx)] */

/* Aggregates all the acks */
select-min-ack(A)
	-o [min => Tx | B | !edge(A,B), ack(A, B, Tx), update-time(A, Tm, Tx) | min-ack(A,Tx)].
/* How to update Tm upon reception of each ack? */

receive-ack(A, B, Tx),
countdown(A, N)
        -o ack(A, B, Tx),
	   countdown(A, N - 1).

countdown(A, 0), !counter(A, N) -o select-min-ack(A), countdown(A, N).

/* Conditions to enter in CS */
/* 1) The request from the local processor has the lowest T */
/* 2) All the acks have been received and their T is greater than local time */
ressource-requested(A)
min-request(A,Ty),
my-time(A, Tm),
Tm<Ty,
min-ack(A,Tx),
Tm<Tx
	-o CS(A), my-time(A, Tm).

/* We can enter the CS */
/* After it's done we release the CS */
!edge(A,B),
my-time(Tm),
CS(A)
	-o CS_instructions(A),
	set-color(A, 255, 0, 0),
	{B | !edge(A, B) | remove-request(B, A, Tm)},
	request-ressource(A)@+1s.
/* How and we retrieve the right Tm without using a sorted queue? */
/* Do we have a guarantee that CS() will be executed before remove-request?*/